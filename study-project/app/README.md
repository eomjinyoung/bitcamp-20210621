# 16-b. 파일 입출력 다루기 : 텍스트 형식으로 데이터 입출력

이번 훈련에서는 **character stream class** 를 활용하여 데이터를 텍스트 포맷으로 파일에 저장하고 파일에서 읽는 것을 연습할 것이다. 

**character stream class** 는,
- 문자 데이터를 출력할 때 UCS2(UTF-16BE) 인코딩 문자를 UTF-8 등과 같은 다른 문자집합의 인코딩으로 자동 변환해준다.
- 문자 데이터를 읽을 때는 꺼꾸로 UTF-8 등으로 인코딩 된 데이터를 JVM이 내부에서 사용하는 UCS2(UTF-16BE) 인코딩으로 자동 변환해준다.
- 즉 개발자가 인코딩 변환을 위한 코드를 작성할 필요가 없어 편하다.

**바이너리 포맷** vs **텍스트 포맷**
- 휴먼 가독성
  - 바이너리 포맷은 사람이 보기가 불편하다.
  - 텍스트 포맷은 사람이 직접 보고 편집할 수 있다.
- 전용 애플리케이션
  - 바이너리 포맷은 그 포맷을 이해하는 애플리케이션을 이용해야만 읽고 쓸 수 있다.
  - 텍스트 포맷은 메모장과 같은 텍스트 에디터만 있으면 읽고 쓸 수 있다.
- 파일 크기
  - 바이너리 포맷은 텍스트 포맷에 비해 크기가 작다.
  - 바이너리 포맷은 각 데이터의 크기를 규정해 놓고 쓰고 읽는다.
  - 텍스트 포맷은 메타 데이터(예: 태그=마크업)를 이용하여 데이터를 구분한다.
    - 메타 데이터 때문에 파일의 크기가 커진다.
- 이기종 언어나 플랫폼 간 호환성
  - 일반 바이너리 포맷은 이기종 프로그래밍 언어간 교환이 가능하다.
  - 그러나 자바의 serialize 와 같은 특정 포맷은 다른 언어에서 읽고 쓸 수 없다.
  - 포토샵 같은 특정 애플리케이션 전용 포맷은 다른 언어에서 읽고 쓸 수 없다.
  - 테스트 포맷은 이기종 프로그래밍 언어에서도 자유롭게 읽고 쓸 수 있다.
    - 그래서 텍스트 포맷은 이기종 플랫폼(OS)이나 애플리케이션 간에 데이터를 교환할 때 주로 사용한다.
    - 예) XML, CSV, JSON 등


## 훈련 목표

- character stream class 를 이용하여 데이터를 텍스트 포맷으로 파일에 쓰고 읽는 것을 연습한다.
- *바이너리 포맷* 과 *텍스트 포맷* 의 특징을 이해한다.
- CSV 파일 포맷의 규칙을 이해한다.

## 훈련 내용

- `FileReader/FileWriter` 를 사용하여 게시글, 회원, 프로젝트, 작업 데이터를 읽고 쓴다.
- 데이터는 CSV 포맷으로 저장한다.


## 실습

**app-15** 를 가져와서 작업한다.

### 1단계 - FileWriter/FileReader를 사용하여 데이터를 CSV 형식으로 파일에 저장하고 읽는다.

텍스트 형식으로 저장할 때 **CSV(Comma-Seperated Values)** 포맷으로 저장한다.

**CSV 파일 포맷** 은,

- **Comma-Seperated Values** 의 약자이다.
- 확장자는 `.csv` 를 사용한다.
- MIME(Multi-purpose Internet Mail Extensions) 형식은 `text/csv` 로 표현한다.
- 각 레코드(한 단위의 값)는 한 줄의 문자열로 표현한다.
- 한 줄은 줄바꿈 기호(CRLF)로 구분한다.
- 레코드를 구성하는 필드는 콤마(,)로 구분한다.
```csv
aaa,bbb,ccc (CRLF)
```
- 각 필드는 큰 따옴표를 쳐도 되고 안쳐도 된다.
```csv
aaa,"bbb",ccc (CRLF)
```
- 파일에 저장할 때 마지막 레코드는 줄바꿈 기호가 있을 수도 있고 없을 수도 있다.
``` csv
aaa,bbb,ccc (CRLF)
aaa,bbb,ccc (CRLF)
aaa,bbb,ccc
```
- CSV에 대한 자세한 정의는 [RFC 4180](https://tools.ietf.org/html/rfc4180) 명세에 있다.


**레코드(record)** 는

- 컴퓨터 과학에서 한 단위의 정보를 가리키는 용어다.
  - 예) 학생정보, 성적정보, 도서정보, 주문정보, 결제정보, 고객정보 등
- 한 개의 이상의 필드(field)로 구성된다.
  - 예) 학생정보: 이름, 전화번호, 나이, 우편번호, 주소, 이메일, 암호 등
- 객체지향 프로그래밍에서 레코드는 보통 클래스로 정의한다.
```java
class Student { // 학생 정보
  ...
}
```
- 필드는 클래스의 인스턴스 필드로 정의한다.
```java
class Student {
    String name; // 이름
    String tel; // 전화번호
    int age; // 나이
    String email; // 이메일
}
```

- com.eomcs.pms.App 클래스 변경
  - 애플리케이션 종료할 때 게시글 데이터를 CSV 형식으로 저장한다.
    - 백업: App.java.01
  - 애플리케이션을 시작할 때 CSV 형식으로 저장된 게시글 데이터를 읽어 온다.
    - 백업: App.java.02


### 2단계 - 데코레이터 PrintWriter/BufferedReader를 사용하여 한 줄의 문자열을 다룬다.

- 학습 목표
  - java.io.* 패키지의 스트림 클래스들은 데코레이터 설계 기법에 따라 만들어졌다.
  - 데코레이터를 사용하면 기존 클래스를 변경하지 않고 기존 기능을 확장할 수 있다.
  - 데코레이터를 사용하면 기능을 붙이기 쉽고 떼기도 쉽다.

- com.eomcs.pms.App 클래스 변경
  - 파일에서 한 줄의 문자열을 읽을 때 BufferedReader 데코레이터를 사용한다.
  - 파일에 한 줄의 문자열을 출력할 때 PrintWriter 데코레이터를 사용한다.
  - 백업: App.java.03

### 3단계 - 데코레이터 BufferedReader/BufferedWriter를 사용하여 입출력 속도를 높힌다.

- com.eomcs.pms.App 클래스 변경
  - 데이터를 읽을 때 이미 버퍼 기능을 갖는 데코레이터는 적용되어 있다.
  - 데이터를 쓸 때 버퍼 기능을 사용하도록 BufferedWriter 데코레이터를 붙인다. 
  - 백업: App.java.04

### 4단계 - 리팩토링 : 'Information Expert' GRASP 적용

이번 단계에서는,
- 좀 더 유지보수하기 좋은 구조로 소스 코드를 **리팩터링** 을 해보자.
- 객체지향 설계 기법 중에서 **GRASP 패턴** 의 하나인 **Information Expert** 를 적용해본다.

**리팩터링(refactoring)** 은, (마틴 파울러의 '리팩터링'에서 발췌)
- 소프트웨어를 보다 쉽게 이해할 수 있고, 적은 비용으로 수정할 수 있도록
  겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는 것.
- 중복된 코드를 제거하여 설계(design)를 개선시킨다.
- 코드를 더 이해하기 쉽게 만든다.
- 버그를 찾기 쉽게 해준다.
- 프로그램을 빨리 작성하도록 도와준다.

**리팩터링** 을 해야할 때,
- 비슷한 코드를 중복해서 작성할 때
- 기능을 추가할 때
- 버그를 수정할 때
- 코드 리뷰(code review)를 수행할 때

**GRASP 패턴**
- General Responsibility Assignment Software Patterns 의 약자이다.
- 객체지향 설계를 수행할 때 일반적으로 적용할 수 있는 설계 원칙이다.
- 객체에 책임(또는 역할)을 부여하는 9가지 원칙을 제안하고 있다.

**Information Expert 패턴**
- GRASP 설계 기법 중 하나이다.
- 데이터를 가지고 있는 객체에게 책임을 부여하는 설계 방식이다.
- 보통 데이터는 비공개로 감추고, 메서드를 통해 데이터를 노출하는 방식을 취한다.

- GRASP 패턴(General Responsibility Assignment Software Pattern): Information Expert
  - 정보를 다루는 일은 그 정보를 갖고 있는 객체가 하는 게 유지보수에 좋다.
  - 도메인 객체(예: Board, Member, Project, Task)에서 필드 값을 CSV 문자열로 리턴하도록 역할을 부여한다.
- com.eomcs.pms.domain.Board 클래스 변경
  - toCsvString() 메서드 추가
    - 데이터를 갖고 있는 클래스가 CSV 문자열을 만든다.
  - valueOfCsv(String) 스태틱 메서드 추가
    - CSV 문자열을 만드는 객체가 인스턴스를 초기화한다.
- com.eomcs.pms.App 클래스 변경
  - 현재는 게시글 객체를 출력할 때 CSV 형식의 문자열로 만드는 일을 App 클래스가 했다.
    - 변경: 게시글 정보를 갖고 있는 Board 클래스가 CSV 형식의 문자열을 만들도록 책임을 위임하라.
  - 백업: App.java.05

### 5단계 - 리팩토링 : '메서드 추출'

- 메서드 추출
  - 특정 기능을 수행하는 코드를 별도의 메서드로 분리한다.
- com.eomcs.pms.App 클래스 변경
  - saveBoards() 메서드 추가 : 게시글 데이터를 파일에 저장한다.
  - loadBoards() 메서드 추가 : 게시글 데이터를 파일에서 로드한다.
  - 백업: App.java.06

### 6단계 - 리팩토링 : 제네릭 적용

이번 단계에서는,
- **인터페이스** 를 활용하여 코드를 통합하는 것을 연습할 것이다.
- **제네릭** 을 활용하여 범용 메서드를 만드는 방법을 연습할 것이다.
- **메서드 레퍼런스** 를 이용하여 스태틱 메서드를  인터페이스 구현체로 사용하는 방법을 연습할 것이다.
- **메서드 레퍼런스** 를 이용하여 생성자를 인터페이스 구현체로 사용하는 방법을 연습할 것이다.

**인터페이스(interface)** 는,
- 객체의 사용 규칙을 정의하는 문법이다.
- 즉 객체에 대해 메서드 호출 규칙을 정의한다.

**인터페이스** 의 이점은,
- 객체를 사용하는 측(client)의 코드 작성과 피사용측 코드 작성을 분리할 수 있다.
- 즉 코드를 작성하는 개발자들이 서로 영향을 끼치지 않고 프로그래밍을 할 수 있다.  
- 특정 클래스에 종속되지 않기 때문에 구현이 더 자유롭고 객체를 대체하기가 더 쉽다.

- 제네릭 적용
  - 한 개의 메서드로 여러 타입을 다룰 수 있다.
- com.eomcs.csv.CsvValue 인터페이스 정의
  - CSV 형식의 문자열을 다루는 객체는 반드시 이 규칙에 따라 작성해야 한다.
  - 즉 이 규칙에 따라 동작하는 메서드를 구비하고 있어야 한다.
  - toCsvString() 메서드 선언
    - 객체의 필드 값을 CSV 형식의 문자열로 만들어 리턴한다.
  - loadCsv(String csv) 메서드 선언
    - CSV 문자열에서 값을 추출하여 객체의 필드에 할당한다.
- com.eomcs.pms.domain.Board 클래스 변경
  - CsvValue 인터페이스를 구현한다.
- com.eomcs.pms.domain.Member 클래스 변경
  - CsvValue 인터페이스를 구현한다.
- com.eomcs.pms.domain.Project 클래스 변경
  - CsvValue 인터페이스를 구현한다.
- com.eomcs.pms.App 클래스 변경
  - saveBoards()를 saveObjects() 메서드로 변경
    - Board 클래스 외에 다른 타입의 객체도 출력할 수 있게 하려고.
  - loadBoards()를 loadObjects() 메서드로 변경
    - Board 클래스 외에 다른 타입의 객체로 로딩할 수 있게 하려고.
  - 백업: App.java.07

### 7단계 - 리팩토링: Task 도메인 클래스에 CsvValue 인터페이스 적용

- com.eomcs.pms.domain.Task 클래스 변경
  - CsvValue 인터페이스를 구현한다.
- com.eomcs.pms.domain.Project 클래스 변경
  - toCsvString() 변경
  - loadCsv() 변경


### 8단계 - JSON 형식으로 데이터를 입출력하기

이번 단계에서는,
- **JSON(JavaScript Object Notation)** 형식으로 입출력하는 것을 연습할 것이다.
- *JSON* 형식을 다루기 위해 **Gson** 외부 라이브러리를 활용할 것이다.

**JSON** 은,
- 속성-값 또는 키-값 으로 된 데이터 객체를 텍스트로 표현하는 개방형 표준 데이터 포맷이다.
```
{속성:값, 속성:값, ...}
예) {"no":1,"name":"1","email":"1","password":"1","photo":"1","tel":"1"}
```
- 텍스트 형식이기 때문에 프로그래밍 언어나 운영체제에 영향을 받지 않는다.
- 바이너리 방식에 비해 데이터 커지는 문제가 있지만,
  모든 프로그래밍 언어에서 다룰 수 있다는 장점이 있다.
- 인터넷 상에서 애플리케이션 간에 데이터를 주고 받을 때 주로 사용한다.
- 특히 이기종 플랫폼(OS, 프로그래밍 언어 등) 간에 데이터를 교환할 때 유용하다.
- JSON 공식 홈인 https://www.json.org 사이트에 자세한 내용이 있다.

**JSON 라이브러리**,
- JSON 데이터 포맷을 다루는 라이브러리다.
- JSON 홈페이지에 다양한 프로그래밍 언어에서 사용할 수 있는 라이브러리를 소개한다.

**Gson**,
- 구글에서 제공하는 JSON 자바 라이브러리다.
- 자바 객체를 JSON 형식의 텍스트로 변환하는 기능을 제공한다.
- JSON 형식의 텍스트를 자바 객체로 변환하는 기능을 제공한다.

1) **Gson** 라이브러리를 프로젝트에 추가한다.
- `build.gradle` 빌드 스크립트 파일 변경
  - Gson 라이브러리 정보를 dependecies {} 블록에 추가한다.
    - https://search.maven.org/ 사이트에 방문한다.
    - `gson` 검색어로 라이브러리를 찾는다.
    - `com.google.code.gson` 라이브러리를 선택한다.
    - 검색 결과에서 최신 버전을 선택한다.
    - Gradle Groovy DSL 코드를 복사하여 빌드 스크립트에 붙여 넣는다.
  - `$ gradle eclipse` 를 실행하여 라이브러리를 다운로드하여 프로젝트에 등록한다.
    - 명령을 실행한 후 eclipse IDE 에서 해당 프로젝트를 refresh 해야 한다.
    - 'Referenced Libraries' 노드에서 gson 라이브러리 파일이 추가된 것을 확인한다.

- com.eomcs.pms.App 클래스 변경
  - saveObjects() 변경 : CSV 형식 대신에 JSON 형식으로 저장한다.
  - loadObjects() 변경 : JSON 형식으로 저장된 데이터를 로드한다.
  - service() 변경 : saveObjects(), loadObjects() 호출할 때 파라미터 값 변경.
  - 백업: App.java.08