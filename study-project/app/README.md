# 16-b. 파일 입출력 다루기 : 텍스트 형식으로 데이터 입출력

이번 훈련에서는 **character stream class** 를 활용하여 데이터를 텍스트 포맷으로 파일에 저장하고 파일에서 읽는 것을 연습할 것이다. 

**character stream class** 는,
- 문자 데이터를 출력할 때 UCS2(UTF-16BE) 인코딩 문자를 UTF-8 등과 같은 다른 문자집합의 인코딩으로 자동 변환해준다.
- 문자 데이터를 읽을 때는 꺼꾸로 UTF-8 등으로 인코딩 된 데이터를 JVM이 내부에서 사용하는 UCS2(UTF-16BE) 인코딩으로 자동 변환해준다.
- 즉 개발자가 인코딩 변환을 위한 코드를 작성할 필요가 없어 편하다.

**바이너리 포맷** vs **텍스트 포맷**
- 휴먼 가독성
  - 바이너리 포맷은 사람이 보기가 불편하다.
  - 텍스트 포맷은 사람이 직접 보고 편집할 수 있다.
- 전용 애플리케이션
  - 바이너리 포맷은 그 포맷을 이해하는 애플리케이션을 이용해야만 읽고 쓸 수 있다.
  - 텍스트 포맷은 메모장과 같은 텍스트 에디터만 있으면 읽고 쓸 수 있다.
- 파일 크기
  - 바이너리 포맷은 텍스트 포맷에 비해 크기가 작다.
  - 바이너리 포맷은 각 데이터의 크기를 규정해 놓고 쓰고 읽는다.
  - 텍스트 포맷은 메타 데이터(예: 태그=마크업)를 이용하여 데이터를 구분한다.
    - 메타 데이터 때문에 파일의 크기가 커진다.
- 이기종 언어나 플랫폼 간 호환성
  - 일반 바이너리 포맷은 이기종 프로그래밍 언어간 교환이 가능하다.
  - 그러나 자바의 serialize 와 같은 특정 포맷은 다른 언어에서 읽고 쓸 수 없다.
  - 포토샵 같은 특정 애플리케이션 전용 포맷은 다른 언어에서 읽고 쓸 수 없다.
  - 테스트 포맷은 이기종 프로그래밍 언어에서도 자유롭게 읽고 쓸 수 있다.
    - 그래서 텍스트 포맷은 이기종 플랫폼(OS)이나 애플리케이션 간에 데이터를 교환할 때 주로 사용한다.
    - 예) XML, CSV, JSON 등


## 훈련 목표

- character stream class 를 이용하여 데이터를 텍스트 포맷으로 파일에 쓰고 읽는 것을 연습한다.
- *바이너리 포맷* 과 *텍스트 포맷* 의 특징을 이해한다.
- CSV 파일 포맷의 규칙을 이해한다.

## 훈련 내용

- `FileReader/FileWriter` 를 사용하여 게시글, 회원, 프로젝트, 작업 데이터를 읽고 쓴다.
- 데이터는 CSV 포맷으로 저장한다.


## 실습

**app-15** 를 가져와서 작업한다.

### 1단계 - FileWriter/FileReader를 사용하여 데이터를 CSV 형식으로 파일에 저장하고 읽는다.

텍스트 형식으로 저장할 때 **CSV(Comma-Seperated Values)** 포맷으로 저장한다.

**CSV 파일 포맷** 은,

- **Comma-Seperated Values** 의 약자이다.
- 확장자는 `.csv` 를 사용한다.
- MIME(Multi-purpose Internet Mail Extensions) 형식은 `text/csv` 로 표현한다.
- 각 레코드(한 단위의 값)는 한 줄의 문자열로 표현한다.
- 한 줄은 줄바꿈 기호(CRLF)로 구분한다.
- 레코드를 구성하는 필드는 콤마(,)로 구분한다.
```csv
aaa,bbb,ccc (CRLF)
```
- 각 필드는 큰 따옴표를 쳐도 되고 안쳐도 된다.
```csv
aaa,"bbb",ccc (CRLF)
```
- 파일에 저장할 때 마지막 레코드는 줄바꿈 기호가 있을 수도 있고 없을 수도 있다.
``` csv
aaa,bbb,ccc (CRLF)
aaa,bbb,ccc (CRLF)
aaa,bbb,ccc
```
- CSV에 대한 자세한 정의는 [RFC 4180](https://tools.ietf.org/html/rfc4180) 명세에 있다.


**레코드(record)** 는

- 컴퓨터 과학에서 한 단위의 정보를 가리키는 용어다.
  - 예) 학생정보, 성적정보, 도서정보, 주문정보, 결제정보, 고객정보 등
- 한 개의 이상의 필드(field)로 구성된다.
  - 예) 학생정보: 이름, 전화번호, 나이, 우편번호, 주소, 이메일, 암호 등
- 객체지향 프로그래밍에서 레코드는 보통 클래스로 정의한다.
```java
class Student { // 학생 정보
  ...
}
```
- 필드는 클래스의 인스턴스 필드로 정의한다.
```java
class Student {
    String name; // 이름
    String tel; // 전화번호
    int age; // 나이
    String email; // 이메일
}
```

- com.eomcs.pms.App 클래스 변경
  - 애플리케이션 종료할 때 게시글 데이터를 CSV 형식으로 저장한다.
    - 백업: App.java.01
  - 애플리케이션을 시작할 때 CSV 형식으로 저장된 게시글 데이터를 읽어 온다.
    - 백업: App.java.02


### 2단계 - 데코레이터 PrintWriter/BufferedReader를 사용하여 한 줄의 문자열을 다룬다.

- 학습 목표
  - java.io.* 패키지의 스트림 클래스들은 데코레이터 설계 기법에 따라 만들어졌다.
  - 데코레이터를 사용하면 기존 클래스를 변경하지 않고 기존 기능을 확장할 수 있다.
  - 데코레이터를 사용하면 기능을 붙이기 쉽고 떼기도 쉽다.

- com.eomcs.pms.App 클래스 변경
  - 파일에서 한 줄의 문자열을 읽을 때 BufferedReader 데코레이터를 사용한다.
  - 파일에 한 줄의 문자열을 출력할 때 PrintWriter 데코레이터를 사용한다.
  - 백업: App.java.03





- App 클래스
  - 애플리케이션을 종료할 때 게시글 데이터를 파일에 저장하는 `saveBoards()`를 정의한다.
  - 애플리케이션을 실행했을 때 파일에서 게시글 데이터를 읽어오는 `loadBoards()`를 정의한다.
  - 게시글 데이터를 저장할 List 객체는 위에서 만든 메서드에서 접근할 수 있도록 스태틱 필드로 전환한다.

#### 작업 파일

- com.eomcs.pms.App 변경

### 2단계 - 회원 데이터를 파일에 보관한다.

- App 클래스
  - 애플리케이션을 종료할 때 회원 데이터를 파일에 저장하는 `saveMembers()`를 정의한다.
  - 애플리케이션을 실행했을 때 파일에서 회원 데이터를 읽어오는 `loadMembers()`를 정의한다.
  - 회원 데이터를 저장할 List 객체는 위에서 만든 메서드에서 접근할 수 있도록 스태틱 필드로 전환한다.

#### 작업 파일

- com.eomcs.pms.App 변경


### 3단계 - 프로젝트 데이터를 파일에 보관한다.

- App 클래스
  - 애플리케이션을 종료할 때 프로젝트 데이터를 파일에 저장하는 `saveProjects()`를 정의한다.
  - 애플리케이션을 실행했을 때 파일에서 프로젝트 데이터를 읽어오는 `loadProjects()`를 정의한다.
  - 프로젝트 데이터를 저장할 List 객체는 위에서 만든 메서드에서 접근할 수 있도록 스태틱 필드로 전환한다.

#### 작업 파일

- com.eomcs.pms.App 변경


### 4단계 - 작업 데이터를 파일에 보관한다.

- App 클래스
  - 애플리케이션을 종료할 때 작업 데이터를 파일에 저장하는 `saveTasks()`를 정의한다.
  - 애플리케이션을 실행했을 때 파일에서 작업 데이터를 읽어오는 `loadTasks()`를 정의한다.
  - 작업 데이터를 저장할 List 객체는 위에서 만든 메서드에서 접근할 수 있도록 스태틱 필드로 전환한다.

#### 작업 파일

- com.eomcs.pms.App 변경


## 실습 결과

- src/main/java/com/eomcs/pms/App.java 변경
